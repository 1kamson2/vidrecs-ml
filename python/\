from typing import List
import psycopg
import pandas as pd
from psycopg.errors import IoError
from pathlib import Path

class Database:
    def __init__(self, name: str, user: str, host: str = "127.0.0.1", port: int 
                 = 5432):
        self.name: str = name
        self.user: str = user
        self.host: str = host 
        self.port: int = port  

    def table_init(self, tablename: str = "movies")->None: 
        """
                                    tablename
        +--------+---------+--------------+--------+---------+-------------+
        |   id   | imdbid  |    title     | genres | ratings | users_rated |
        +--------+---------+--------------+--------+---------+-------------+
        | SERIAL | SERIAL  | VARCHAR(128) | TEXT[] | REAL    | SERIAL      |
        +--------+---------+--------------+--------+---------+-------------+
              ^---- PRIMARY KEY
            Furthermore, your dataset should be csv, with the following
            structure:
                --> links.csv: movieid, imdbid, tmdbid (up to two sources of
                movie ids)
                --> movies.csv: movieid, title, genres
                --> ratings.csv: userid, movieid, rating, timestamp
                --> tags.csv: userid, movieid, tag, timestamp
            Preferably the user, should pass with those names and shouldn't be
            changed.
            We can calculate rating easily.
        """
        if not self.exists(tablename):
            print("[INFO] table_init(): Table doesn't exist. Creating one")
            try:
                # --- TODO: probably should make construct_query to handle some bad
                # injections etc --- # 
                create_table_query = """CREATE TABLE {tablename} ( 
                    id SERIAL PRIMARY KEY,
                    imdbid SERIAL,
                    title VARCHAR(128),
                    genres TEXT[],
                    ratings REAL,
                    users_rated SERIAL
                    )""".format(tablename=tablename) 
                self.make_query(query=create_table_query)
            except IOError as e:
                print(f"[ERROR] table_init(): Couldn't create given table.\n{e}")
                exit(1) 

            try:
                with psycopg.connect(dbname=self.name, 
                                     user=self.user, 
                                     host=self.host,
                                     port=self.port) as conn:

                    with conn.cursor() as cur:
                        query = """INSERT INTO movies(id, imdbid, title, genres,
                                                     ratings, users_rated)
                                                     VALUES(%s, %s, %s,
                                                     %s, %s, %s)"""

                        # --- Load movies into the database --- #
                        print("[INFO] table_init(): Loading all movies.")
                        # --- TODO: Keep this paths in json files (or TOML) and
                        # read it to Path(...) --- #
                        csv_files = list(Path("./resource/").glob("*.csv")) 
                        print(f"[INFO] Found those files:\n{csv_files}")
                        movies_data = dict() 

                        if Path("resource/links.csv") not in csv_files:
                            print("[ERROR] links.csv wasn't found.")
                            exit(1)

                        link_df = pd.read_csv("resource/links.csv", sep=',', skiprows=0)
                        for relation in link_df.itertuples(index=False, name=None):
                            movieid, imdbid, *_ = relation
                            entry = [0 for _ in range(6)]
                            entry[0] = movieid
                            entry[1] = imdbid
                            movies_data[movieid] = entry
                        # --- Drop the reference --- #
                        del link_df

                        if Path("resource/movies.csv") not in csv_files:
                            print("[ERROR] links.csv wasn't found.")
                            exit(1)

                        movies_df = pd.read_csv("resource/movies.csv", sep=',', skiprows=0)
                        for relation in movies_df.itertuples(index=False, name=None):
                            movieid, title, genres = relation
                            # --- Get entry info --- #
                            entry = movies_data[movieid]
                            entry[2] = title 
                            entry[3] = genres.split('|') 
                            # --- Replace with new entry --- #
                            movies_data[movieid] = entry

                        del movies_df

                        if Path("resource/ratings.csv") not in csv_files:
                            print("[ERROR] ratings.csv wasn't found.")
                            exit(1)

                        ratings_df = pd.read_csv("resource/ratings.csv", sep=',', skiprows=0)
                        for relation in ratings_df.itertuples(index=False, name=None):
                            _, movieid, rating, _ = relation
                            # --- Get entry info --- #
                            entry = movies_data[movieid]
                            entry[4] += rating 
                            entry[5] += 1 
                            # --- Replace with new entry --- #
                            movies_data[movieid] = entry
                        del ratings_df
                        # TODO: For now skipping the tags.csv
                        
            except IOError as e:
                print(e)
                exit(1)

            try:
                print("[INFO] Here are 10 elements of your dataset.")
                for k, v in movies_data.items():
                    if k == 10:
                        break
                    print(f"key: {k} value: {v}")

                for relation in movies_data.values():
                    cur.execute(query, relation)

            except IOError as e:
                print(e)
                exit(1)


        return

    def exists(self, tablename: str) -> bool:
        try:
            with psycopg.connect(dbname=self.name, 
                                 user=self.user, 
                                 host=self.host,
                                 port=self.port) as conn:

                with conn.cursor() as cur:
                    query = "SELECT EXISTS(SELECT * FROM information_schema.tables WHERE table_name=%s)"
                    cur.execute(query, (tablename,))
                    return cur.fetchone()[0] 
        except IoError as e: 
            print(f"[ERROR] exists(): Failed to execute the query.\n{e}")
            exit(1)


    def make_query(self, query: str ="", *args)-> None:
        """
            Parameters:
                query: what should this function execute
                args: arguments for query
        """

        if len(query) == 0:
            print("[WARNING] Query is length of 0, query omitted.")
            return

        try:

            with psycopg.connect(dbname=self.name, 
                                 user=self.user, 
                                 host=self.host,
                                 port=self.port) as conn:

                with conn.cursor() as cur:
                    # --- Sample query, not final --- #
                    cur.execute(query, args)
                    
        except IoError as e: 
            print(f"[ERROR] make_query(): Failed to execute the query.\n{e}")


    def fill_database(self, batch: List): 
        try:
            with psycopg.connect(dbname=self.name, 
                                 user=self.user, 
                                 host=self.host,
                                 port=self.port) as conn:

                with conn.cursor() as cur:
                    query = "SELECT EXISTS(SELECT * FROM information_schema.tables WHERE table_name=%s)"
                    cur.execute(query, (tablename,))
                    return cur.fetchone()[0] 
        except IoError as e: 
            print(f"[ERROR] exists(): Failed to execute the query.\n{e}")
            exit(1)


    def transaction(self):
        assert 1 != 1, "TODO: Not initialized"
        return

